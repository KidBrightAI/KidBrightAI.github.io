!function(e){var t={};function n(o){if(t[o])return t[o].exports;var l=t[o]={i:o,l:!1,exports:{}};return e[o].call(l.exports,l,l.exports,n),l.l=!0,l.exports}n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var l in e)n.d(o,l,function(t){return e[t]}.bind(null,l));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(object,e){return Object.prototype.hasOwnProperty.call(object,e)},n.p="/_nuxt/",n(n.s=0)}([function(module,exports){importScripts("https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"),importScripts("https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier");let processing=!1,sourceCode="",__model=null,__labels=[],__keypoint=null,__data=null,__maxIndex=0,responseCallback=null,eventCallback=[],requestCommand=null;const requestData=async function(e,t){requestCommand=e;let n={command:"REQUEST",data:e};t&&(n=Object.assign(n,t)),postMessage(n);let o=new Promise((e=>responseCallback=e));return await o},registerCallback=async function(e,t){eventCallback.push({name:e,callback:t})},unregisterCallback=async function(e){eventCallback=eventCallback.filter((t=>t.name!=e))},loadingModel=async function(){let e=await requestData("MODEL");if(e.model.includes("knn")){postMessage({command:"PRINT",msg:"--- create kNN model ---\r\n"}),__model=knnClassifier.create(),__model.clearAllClasses();for(let t of e.dataset)__model.addExample(tf.tensor(t.keypoints),t.class);let t=__model.getClassExampleCount(),n="kNN dataset : ";for(let e of Object.keys(t))n+=e+" > "+t[e]+",";postMessage({command:"PRINT",msg:"--- create kNN model ---\r\n"}),postMessage({command:"PRINT",msg:n+"\r\n"})}},__classify=async function(img){return await __model.predictClass(img)},initModel=async function(){postMessage({command:"PRINT",msg:"Loading model\r\n"}),await loadingModel(),postMessage({command:"PRINT",msg:"Loading labels\r\n"}),postMessage({command:"PRINT",msg:"Label : "+__labels.join(",")+"\r\n"}),postMessage({command:"PRINT",msg:"Model loaded\r\n"})},classify=async function(){if(__image=await requestData("IMAGE"),!__image)return;let e=await tf.tensor(__image);__data=await __classify(e)};onmessage=async e=>{if("RUN"==e.data.command)sourceCode=e.data.code,__labels=e.data.labels,processing||(processing=!0,process());else if("RESPONSE"==e.data.command)e.data.subcommand==requestCommand&&responseCallback(e.data.data);else if("EVENT"==e.data.command){let t=eventCallback.filter((t=>t.name==e.data.subcommand));for(let n of t)"AsyncFunction"==n.callback.constructor.name?await n.callback(e.data.data):n.callback(e.data.data)}};const process=function(){try{eval(sourceCode)}catch(e){postMessage({command:"PRINT",msg:"ERROR !!! \r\n"+e.message})}}}]);